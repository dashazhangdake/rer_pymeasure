"""hp4156.pyCurrent version development: 0.2python version: 3.xAuthor: Xun LiCopyright (c) 2022 Vanderbilt University. All rights reserved."""import sys, osimport timeimport pandas as pdimport numpy as npimport pymeasurefrom pymeasure.adapters import VXI11Adapterfrom pymeasure.instruments import Instrumentclass hp4156(Instrument):    def __init__(self, adapter, resourceName, **kwargs):        super().__init__(adapter,                         resourceName,                         **kwargs,                         timeout=540000)    def reset(self):        """Resets configuration of HP 4156A to default."""        self.write("*rst")        pass    def measurementMode(self, arg1, arg2):        """		arg1 is the measurement mode. Valid arguements are Sweep = SWE, Sampling = SAMP, Quasi-static CV measurement = QSCV.				arg2 is the integration time. Valid arguments are short = SHOR, medium = MED, long = LONG.		"""        # self.write(":PAGE:CHAN:CDEF")        self.analyzer_mode =arg1        if (arg1 == "SWE" or arg1 == "SAMP" or arg1 == "QSCV") and (arg2 == "SHOR" or arg2 == "LONG" or arg2 == "MED"):            self.write(":PAGE:CHAN:MODE " + arg1)            self.write(":PAGE:MEAS:MSET:ITIM %s" + arg2)        else:            print("Invalid measurement mode or integration time. Exiting.")            sys.exit()        pass    def stringSmuMod(self, arg):        """		Method only called when appropriate, users don't need to modify their input. Generally I will know when it is appropriate to do this and do so accordingly.		"""        arg[0] = "'" + arg[0] + "'"        arg[2] = "'" + arg[2] + "'"        return arg    def smu(self, arg1, arg2):        """		Defines parameters for setting up an SMU on the HP 4156A. 				arg1 is the desired SMU, ie SMU1, SMU2, etc, entered as a string variable. 				arg2 is the parameters for that SMU. ie smu1 = ['VD','CONS','ID','V','0.1','3mA'] # Variable NAME, Variable FUNCtion(var, cons), INAME, MODE (V, I or COMMon), if the variable is constant this requires a value CONStant ,COMPliance for the variable. Where each element is described after the #.		"""        self.arg2 = self.stringSmuMod(arg2)        self.data_variables = []        self.smuSetup = [":PAGE:CHAN:" + arg1 + ":VNAME %s", ":PAGE:CHAN:" + arg1 + ":FUNC %s",                         ":PAGE:CHAN:" + arg1 + ":INAME %s", ":PAGE:CHAN:" + arg1 + ":MODE %s",                         ":PAGE:MEAS:CONS:" + arg1 + " %s", ":PAGE:MEAS:CONS:" + arg1 + ":COMP %s"]        self.write(self.smuSetup[0] % self.arg2[0])        self.write(self.smuSetup[1] % self.arg2[1])        self.write(self.smuSetup[2] % self.arg2[2])        # self.write(":PAGE:DISP:LIST %s" % self.arg2[2])        self.data_variables.append(self.arg2[2])        self.write(self.smuSetup[3] % self.arg2[3])        if arg2[1] != "VAR1" and arg2[1] != "VAR2" and arg2[3] != "COMM" and arg2[1] != "VAR1\'":            self.write(self.smuSetup[4] % arg2[4])            self.write(self.smuSetup[5] % arg2[5])    def disableSmu(self, arg):        """		Disables the specified unit: valid arguments are: VSU1, VSU2, VMU1, VMU2, SMU1, SMU2, SMU3, SMU4. Parameter arg is a list of valid arguements.		"""        for i in arg:            self.write(":PAGE:CHAN:" + i + ":DIS")    def disable_allSmu(self):        """        Disable all the smu        :return:        """        self.write(':PAGE:CHAN:ALL:DIS')    def varStringMod(self, arg):        """		Method only called when appropriate, users don't need to modify their input. Generally I will know when it is appropriate to do this and do so accordingly.		"""        arg[0] = "'" + arg[0] + "'"        return arg    def var(self, arg1, arg2):        """		Describes the measurement parameters for an independent variable, arg1, and its specifications arg2. 				Similar to smu(), we have arg1 as the desired VAR, ie VAR1, VAR2, as a string input. If using VAR2, stop is replaced by number of points.				arg2 describes several critical values of the VAR, ie var1 = ['\'LIN\'','-0.1','0.01','1.5','1nA']	# SPACing (LINear or LOGarithmic), STARting value, STEP size, STOPing value, COMPliance limit.		"""        self.arg2 = self.varStringMod(arg2)        self.string = ":PAGE:MEAS:" + arg1 + ":"        if arg1 == "VAR1":            self.write(self.string + "SPAC %s" % self.arg2[0])            self.write(self.string + "STAR %s" % self.arg2[1])            self.write(self.string + "STEP %s" % self.arg2[2])            self.write(self.string + "STOP %s" % self.arg2[3])            self.write(self.string + "COMP %s" % self.arg2[4])        elif arg1 == "VAR2":            self.write(self.string + "SPAC %s" % self.arg2[0])            self.write(self.string + "STAR %s" % self.arg2[1])            self.write(self.string + "POIN %s" % self.arg2[3])            self.write(self.string + "STEP %s" % self.arg2[2])            self.write(self.string + "COMP %s" % self.arg2[4])    def measure(self, period="INF", points=100):        """        Performs a single measurement and waits for completion in sweep mode.        In sampling mode, the measurement period and number of points can be specified.        :param period: Period of sampling measurement from 6E-6 to 1E11 seconds.                Default setting is :code:`INF`.        :param points: Number of samples to be measured, from 1 to 10001.                Default setting is :code:`100`.        .. code-block::python            instr.measure() #for sweep measurement            nstr.measure(period=100, points=100) #for sampling measurement        """        if self.analyzer_mode == 'SWE' or self.analyzer_mode == 'SWEEP':            self.write(":PAGE:SCON:MEAS:SING; *OPC?")        else:            self.write(f":PAGE:MEAS:SAMP:PER {period}")            self.write(f":PAGE:MEAS:SAMP:POIN {points}")            self.write(":PAGE:SCON:MEAS:SING; *OPC?")        self.write(":PAGE:GLIS:GRAP:SCAL:AUTO ONCE")    def double_sweep(self):        ''' Execute a double sweep measurement'''        self.write("PAGE:MEAS:VAR1:MODE single")    def single_sweep(self):        self.write('PAGE:MEAS:VAR1:MODE DOUBLE')    def visualizeTwoYs(self, x, y1, y2):        """		Takes three list arguments ie:				#x = ['XVAR','LIN',"XMIN","XMAX"]		#y1 = ['Y1VAR','LOG',"Y1MIN","Y1MAX"]		#y2 = ['Y2VAR','LOG',"Y2MIN","Y2MAX"]				Visualizes two sets of data, y1 and y2.		"""        self.x = self.varStringMod(x)        self.y1 = self.varStringMod(y1)        self.y2 = self.varStringMod(y2)        self.write(":PAGE:DISP:GRAP:GRID ON")        self.write(":PAGE:DISP:GRAP:X:NAME %s" % self.x[0])        self.write(":PAGE:DISP:GRAP:Y1:NAME %s" % self.y1[0])        self.write(":PAGE:DISP:GRAP:Y2:NAME %s" % self.y2[0])        self.write(":PAGE:DISP:GRAP:X:SCAL %s" % self.x[1])        self.write(":PAGE:DISP:GRAP:Y1:SCAL %s" % self.y1[1])        self.write(":PAGE:DISP:GRAP:Y2:SCAL %s" % self.y2[1])        self.write(":PAGE:DISP:GRAP:X:MIN %s" % self.x[2])        self.write(":PAGE:DISP:GRAP:Y1:MIN %s" % self.y1[2])        self.write(":PAGE:DISP:GRAP:Y2:MIN %s" % self.y2[2])        self.write(":PAGE:DISP:GRAP:X:MAX %s" % self.x[3])        self.write(":PAGE:DISP:GRAP:Y1:MAX %s" % self.y1[3])        self.write(":PAGE:DISP:GRAP:Y2:MAX %s" % self.y2[3])        pass    def visualize(self, x, y1):        """		Takes two list arguments ie:				x = ['XVAR','LIN',"XMIN","XMAX"]		y1 = ['Y1VAR','LOG',"Y1MIN","Y1MAX"]				Visualizes a set of data, y1.		"""        self.x = self.varStringMod(x)        self.y1 = self.varStringMod(y1)        self.write(":PAGE:DISP:GRAP:GRID ON")        self.write(":PAGE:DISP:GRAP:X:NAME %s" % self.x[0])        self.write(":PAGE:DISP:GRAP:Y1:NAME %s" % self.y1[0])        self.write(":PAGE:DISP:GRAP:X:SCAL %s" % self.x[1])        self.write(":PAGE:DISP:GRAP:Y1:SCAL %s" % self.y1[1])        self.write(":PAGE:DISP:GRAP:X:MIN %s" % self.x[2])        self.write(":PAGE:DISP:GRAP:Y1:MIN %s" % self.y1[2])        self.write(":PAGE:DISP:GRAP:X:MAX %s" % self.x[3])        self.write(":PAGE:DISP:GRAP:Y1:MAX %s" % self.y1[3])        pass    def stop(self):        '''Stop the measurement'''        self.write(":PAGE:SCON:STOP")    def append(self):        self.write(":PAGE:SCON:STOP")    def stress(self, term, func, mode, name, value=0.0, duration=100000):        """Sets up the stress conditions for the 4156."""        self.name = self.varStringMod(name)        self.write(":PAGE:STR:SET:DUR %s" % duration)        self.write(":PAGE:STR:%s:NAME %s" % (term, self.name))        self.write(":PAGE:STR:%s:FUNC %s" % (term, func))        self.write(":PAGE:STR:%s:MODE %s" % (term, mode))        self.write(":PAGE:STR:SET:CONS:%s %s" % (term, value))        pass    def save(self, trace_list):        """ Save the voltage or current in the instrument display list        :param trace_list: A list of channel variables whose measured data should be saved.            A maximum of 8 variables are allowed. If only one variable is being saved, a string            can be specified.        .. code-block:: python            instr.save(['IC', 'IB', 'VC', 'VB']) #for list of variables            instr.save('IC')    #for single variable        """        self.write(":PAGE:DISP:MODE LIST")        if isinstance(trace_list, list):            if len(trace_list) > 8:                raise RuntimeError('Maximum of 8 variables allowed')            else:                self.stuff = []                for name in trace_list:                    name1 = '\'' + name + '\''                    self.stuff.append(name1)                    self.write(":PAGE:DISP:LIST %s" % name1)        elif isinstance(trace_list, str):            self.write(":PAGE:DISP:LIST %s" % trace_list)        else:            raise TypeError(                'Must be a string if only one variable is saved, or else a list if'                'multiple variables are being saved.'            )    def save_var(self, trace_list):        """ Save the voltage or current in the instrument variable list.        This is useful if one or two more variables need to be saved in addition to the 8        variables allowed by :meth:`~.Agilent4156.save`.        :param trace_list: A list of channel variables whose measured   data should be saved.            A maximum of 2 variables are allowed. If only one variable is being saved, a string            can be specified.        .. code-block:: python            instr.save_var(['VA', 'VB'])        """        self.write(":PAGE:DISP:MODE LIST")        if isinstance(trace_list, list):            if len(trace_list) > 2:                raise RuntimeError('Maximum of 2 variables allowed')            else:                for name in trace_list:                    self.write(":PAGE:DISP:DVAR %s" % name)        elif isinstance(trace_list, str):            self.write(":PAGE:DISP:DVAR %s" % trace_list)        else:            raise TypeError(                'Must be a string if only one variable is saved, or else a list if'                'multiple variables are being saved.'            )    def data_variables(self):        """        Get a string list of data variables for which measured data is available.        This looks for all the variables saved by the :meth:`~.Agilent4156.save` and        :meth:`~.Agilent4156.save_var` methods and returns it. This is useful for creation        of dataframe headers.        :returns: List        .. code-block:: python        header = instr.data_variables        """        dlist = self.ask(":PAGE:DISP:LIST?").split(',')        dvar = self.ask(":PAGE:DISP:DVAR?").split(',')        varlist = dvar + dlist        return list(filter(None, varlist))    def get_data(self, path=None):        """        Get the measurement data from the instrument after completion.        If the measurement period is set to :code:`INF` in the :meth:`~.Agilent4156.measure`        method, then the measurement must be stopped using :meth:`~.Agilent4156.stop` before        getting valid data.         param path: Path for optional data export to CSV.        :returns: Pandas Dataframe        .. code-block:: python        df = instr.get_data(path='./datafolder/data1.csv')         """        if int(self.ask('*OPC?')):            header = self.stuff        self.write(":FORM:DATA ASCii")        # recursively get data for each variables,        for i, listvar in enumerate(header):            data = self.values(":DATA? %s" % listvar)            time.sleep(0.01)            if i == 0:                lastdata = data            else:                data = np.column_stack((lastdata, data))                lastdata = data            header[i] = listvar.strip('')        df = pd.DataFrame(data, columns=header, index=None)        if path is not None:            root, ext = os.path.splitext(path)            if ext != ".csv":                path = path + ".csv"            df.to_csv(path, index=False)        return df